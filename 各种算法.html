<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    * {
      margin: 0;
      padding: 0
    }

    .block {
      width: 0;
      height: 0;
      border: 100px solid #000;
      border-left-color: transparent;

    }

  </style>
</head>

<body>
  <ul id="demo">
    <li>123</li>
    <li>123</li>
    <li>123</li>
  </ul>

  <div class="block"></div>
  <script>
    function ajax(methods, data, flag, callback){
      let xhr
      // 创建xhr对象
      if(window.XMLHttpRequest){
        xhr = new XMLHttpRequest()
      } else {
        xhr = new ActiveXObject('Mirc...')
      }

      // 创建http请求
      if(methods == 'get'){
        url += '?' + data + new Date().getTime()
        xhr.open('get', data, flag)
      } else {
        xhr.open('post', data, flag)
      }

      // 设置响应
      xhr.onreadystatechange = function(){
        if(xhr.readyState == 4 && xhr.status == 200){
          callback(xhr.responseText)
        }
      }

      // 发送http请求
      if(methods == 'get'){
        xhr.send()
      } else {
        xhr.setRequestHeader('content-type', 'application/x-www-form-url')
        xhr.send(data)
      }
    }

    // 快速排序
    function quickSort(arr) {
      if (arr.length == 0 || arr == null) return []
      let leader = arr[0]
      let left = []
      let right = []

      for (let i = 1; i < arr.length; i++) {
        if (arr[i] > leader) {
          right.push(arr[i])
        } else {
          left.push(arr[i])
        }
      }
      left = quickSort(left)
      right = quickSort(right)
      left.push(leader)
      return left.concat(right)
    }

    // 

    function demo() {
      setTimeout(function () {
        console.log(this)
      }, 0)
    }
    demo()
    // 快速排序
    function quick(arr) {
      if (arr.length == 0 || !arr) return false
      let leader = arr[0]
      let left = []
      let right = []

      for (let i = 0; i < arr.length; i++) {
        if (arr[i] > leader) {
          right.push(arr[i])
        } else {
          left.push(arr[i])
        }
      }

      left = quick(left)
      right = quick(right)
      return left.push(leader).concat(right)
    }

    // console.log(quickSort([2,6,5,1,3,7,9]))


    // 二分查找
    function find(arr, target) {
      let mid = Math.floor(arr.length / 2)
      if (arr[mid] == target) return mid
      if (target > arr[mid]) {
        find(arr.slice(mid), target)
      } else {
        find(0, mid)
      }
    }

    console.log(find([1,2,3,4,5,5,3,2], 3))

    // 冒泡排序 
    function bubble(arr) {
      for (let i = 0; i < arr.length - 1; i++) {
        for (let j = i + 1; j < arr.length; j++) {
          if (arr[i] > arr[j]) {
            let temp = arr[i];
            arr[i] = arr[j]
            arr[j] = temp
          }
        }
      }
      return arr
    }
    // console.log(bubble([2]))

    // 插入排序
    function cha(arr) {
      for (let i = 1; i < arr.length; i++) {
        let index = i
        while (arr[index] < arr[index - 1] && index > 0) {
          let temp = arr[index]
          arr[index] = arr[index - 1]
          arr[index - 1] = temp
          index--
        }
      }
      return arr
    }

    function cha(arr) {
      for (let i = 1; i < arr.length; i++) {
        let index = i
        while (arr[index] < arr[index - 1] && index > 0) {
          let temp = arr[index]
          arr[index] = arr[index - 1]
          arr[index - 1] = temp
          index--
        }
      }
      return arr
    }

    // console.log(cha([1,6,5,3,2,7,9]))

    // 数组去重 indexOf去重
    function unique1(arr) {
      let res = []
      for (let i = 0; i < arr.length; i++) {
        if (res.indexOf(arr[i]) == -1) {
          res.push(arr[i])
        }
      }
      return res
    }
    // splice 去重
    function unique2(arr) {
      for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length; j++) {
          if (arr[i] == arr[j]) {
            arr.splice(i, 1)
          }
        }
      }
      return arr
    }
    // [...new Set(arr)]
    // 对象属性唯一性去重
    function unique3(arr) {
      let obj = {}
      let res = []
      for (let i = 0; i < arr.length; i++) {
        if (!obj[arr[i]]) {
          obj[arr[i]] = 1
          res.push(arr[i])
        }
      }
      return arr
    }
    let arr = [1, 1, 1, 2, 2, 2, 3, 3, 3]
    //  console.log(unique1(arr))
    //  console.log(unique2(arr))
    //  console.log([...new Set(arr)])
    //  console.log(unique3(arr))

    function Node(val) {
      this.val = val
      this.next = null
    }

    let n1 = new Node(1)
    let n2 = new Node(2)
    let n3 = new Node(3)

    n1.next = n2
    n2.next = n3
    // 链表反转
    function reverse(node) {
      if (!node) return null
      if (!node.next.next) {
        let temp = node.next
        node.next.next = node
        node.next = null
        return temp
      }
      if (node.next.next) {
        let target = reverse(node.next)
        node.next.next = node
        node.next = null
        return target
      }
    }
    // console.log(reverse(n1))

    // 柯里化
    function curry(func, ...arg) {
      return function (...newArg) {
        let _arg = [...arg, ...newArg]
        if (_arg.length == func.length) {
          return func(..._arg)
        } else {
          return curry(func, ..._arg)
        }
      }
    }

    function curry(func, ...arg) {
      return function (...newArg) {
        let _arg = [...arg, ...newArg]
        if (func.length === _arg.length) {
          return func(..._arg)
        } else {
          return curry(func, ..._arg)
        }
      }
    }

    // func()()()

    // 二叉树
    // DLR 前序
    function DLR(root) {
      if (!root) return root
      DLR(root.left)
      DLR(root.right)
    }

    function LDR(root) {
      if (!root.left) return root.left
      LDR(root.left)
    }


    function pre(root) {
      if (!root) return false
      console.log(root.value)
      pre(root.left)
      pre(root.right)
    }
    /*
        A
      B   C
     D E
    H
    */
    // pre ABDHEC
    // pre ABDEC
    // mid DBEAC
    // last DEBCA

    // 前中
    function preMid(pre, mid) {
      let root = pre[0]
      let index = mid.indexOf(root.val)
      let preLeft = pre.slice(1, index + 1)
      let preRight = pre.slice(index + 1)
      let midLeft = pre.slice(0, index)
      let midRight = pre.slice(index + 1)
      root.left = preMid(preLeft, midLeft)
      root.right = preMid(preRight, midRight)
      return root
    }

    function TreeNode(value) {
      this.value = val
      this.left = null;
      this.right = null
    }

    // 深度优先搜索
    function deep(root) {
      if (root == null) return
      if (root.val === target) return true
      let left = deep(root.left)
      let right = deep(root.right)
      return left || right
    }

    // 广度优先
    function width(nodeList, target) {
      if (!nodeList || nodeList.length === 0) return false
      let children = []
      for (let i = 0; i < nodeList.length; i++) {
        if (nodeList[i].value == target) {
          return true
        } else {
          children.push(nodeList[i].left)
          children.push(nodeList[i].right)
        }
      }
      return width(children, target)
    }

    // 深度优先
    function deep(root, target) {
      if (!root) return false
      if (root.value == target) return true
      let left = deep(root.left, target)
      let right = deep(root.right, target)
      return left || right
    }

    // 广度优先
    function width(nodeList, target) {
      if (!nodeList || nodeList.length == 0) return false
      let children = []
      for (let i = 0; i < nodeList.length; i++) {
        if (nodeList[i].value === target) return true
        children.push(nodeList.left)
        children.push(nodeList.right)
      }
      return width(children, target)
    }

    // 深度优先
    function deep(root, target) {
      if (!root) return false
      if (root.value == target) return true
      let left = deep(root.left, target)
      let right = deep(root.right, target)
      return left || right
    }

    // 广度优先
    function width(list, target) {
      if (!list || list.length) return false
      let children = []
      for (let i = 0; i < list.length; i++) {
        if (list[i].value === target) {
          return true
        } else {
          children.push(list[i].left)
          children.push(list[i].right)
        }
      }
      return width(children, target)
    }

    // 二叉树的比较
    function compare(root1, root2) {
      if (root1 == root2) return true
      if (root1 == null && root2 != null || root1 != null && root2 == null) return false
      if (root1 != root2) return false
      let left = compare(root1.left, root2.left)
      let right = compare(root1.right, root2.right)
      return left && right
    }

    // 遍历dom树

    function bian(root) {
      if (!root) return false
      let children = root.children
      if (children.length == 0 || !children) {
        console.log(root)
      }
      for (let i = 0; i < children.length; i++) {
        console.log(children[i])
        bian(children[i].children)
      }
    }

    for (var i = 0; i < 5; i++) {
      if (i != 3) {
        setTimeout((i) => {
          console.log(i)
        }, 0, i)
      } else {
        break
      }
    }

    //二叉树比较
    //注意左右互换后还是不是同一颗二叉树
    function compare(root1, root2) {
      if (root1 == root2) {
        return true;
      }
      if ((root1 == null && root2 != null) || (root2 == null && root1 != null)) {
        return false;
      }
      if (root1.value != root2.value) {
        return false;
      }
      return compare(root1.left, root2.left) && compare(root1.right, root2.right);
    }

    console.log(compare(a1, a2))



    //考虑左右互换
    function compare(root1, root2) {
      if (root1 == root2) {
        return true;
      }
      if ((root1 == null && root2 != null) || (root2 == null && root1 != null)) {
        return false;
      }
      if (root1.value != root2.value) {
        return false;
      }
      return (compare(root1.left, root2.left) && compare(root1.right, root2.right)) ||
        (compare(root1.left, root2.right) && compare(root1.right, root2.left))
    }

    // 平衡二叉树
    function getDeep(root) {
      if (root == null) {
        return 0;
      }
      let left = getDeep(root.left);
      let right = getDeep(root.right);
      return Math.max(left, right) + 1;
    }


    function isBalance(root) {
      if (root == null) {
        return true;
      }
      let leftDeep = getDeep(root.left);
      let rightDeep = getDeep(root.right);
      if (Math.abs(leftDeep - rightDeep) > 1) {
        return false;
      } else {
        return isBalance(root.left) && isBalance(root.right);
      }
    }

    // 选择排序
    function sort(arr) {
      if (arr == null) {
        return;
      }
      let len = arr.length;
      for (i = 0; i < len; i++) {
        let maxIndex = i;
        //之所以 - 1 - i 是因为
        //-1 是因为到了最后一位不需要再和别人比大小了
        //-i 是因为 最大（最小）的都按顺序放到数组最后了，不用再判断他们了
        for (let j = 0; j < len - 1 - i; j++) {
          if (arr[maxIndex] > arr[j]) {
            maxIndex = j
          }
        }
        let temp = arr[maxIndex];
        arr[maxIndex] = arr[len - 1 - i];
        arr[len - 1 - i] = temp;
      }
      return arr
    }


    //防抖
    function deBounce(handler, delay) {
      var timer = null;
      return function () {
        var _self = this,
          _arg = arguments;
        //必须用 timeout
        clearTimeout(timer);
        timer = setTimeout(function () {
          return handler.apply(_self, _arg);
        }, delay);
      }
    }

    // 节流
    function throttle(handler, wait) {
      var lastTime = 0;
      return function () {

        var nowTime = new Date().getTime();
        if (nowTime - lastTime > wait) {
          handler.apply(this, arguments);
          lastTime = nowTime;
        }
      }
    }

    //字符串反转
    var str = "123abc";
    str.split('').reverse().join('');


    //在有序数组中找出指定的值 返回该值的索引
    //二分查找
    function search(arr, value) {
      var low = 0;
      var height = arr.length - 1;
      while (low <= height) {
        var mid = parseInt((height + low) / 2);
        if (arr[mid] == value) {
          return mid;

        } else if (value > arr[mid]) {
          low = mid + 1;

        } else if (value < arr[mid]) {
          height = mid - 1;
        } else {
          return -1;
        }
      }
    }


    //对称数组
    function dui(arr) {
      if (arr == null || arr.length == 0) {
        return false
      }
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] !== arr[arr.length - 1 - i]) {
          return false;
        }

      }
      return true;
    }
    //对称数组第二种方法
    function dui1(arr) {
      if (arr == null || arr.length == 0) {
        return false
      }
      var low = 0;
      var height = arr.length - 1;
      while (true) {
        if (low >= height) {
          break;
        }
        if (arr[low] != arr[height]) {
          return false;
        }
        low++;
        height--;
      }
      return true;
    }

    //查询子串首次出现的位置 如 abcbcxy 子串: bc 位置: 1
    //indexOf  
    //链表 + hash(哈希)
    function childrenStr(str, target) {
      if (str == null || target == null || str.length == 0 || target.length == 0) {
        return -1;
      }

      for (var i = 0; i < str.length - target.length + 1; i++) {
        for (var j = 0; j < target.length; j++) {
          if (arr[i + j] !== target[j]) {
            break;
          }
          if (j == target.length - 1) {
            return i;
          }
        }
      }
      return -1;
    }


    //计算数组中，最大连续增长子序列的长度，如[1,2,3,4,1,2,3,4,5,1,2,3] 结果为5;
    //完成
    function add(arr) {
      var cont = 1;
      var max = 1;
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] < arr[i + 1]) {
          cont++;
        } else {
          if (max < cont) {
            max = cont;
          }
          cont = 1;
        }

      }
      return max;
    }
    // 乘法表
    function chart() {
      for (let i = 1; i < 10; i++) {
        for (let j = 1; j <= i; j++) {
          console.log(j + '*' + i + '=' + j * i)
        }
      }
    }
    // ajax 封装
    function AJAX(json) {
      var url = json.url,
        method = json.method,
        flag = json.flag,
        data = json.data,
        callBack = json.callBack,
        xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new window.XMLHttpRequest();
      } else {
        xhr = new ActiveXObject('Mircosoft.XMLHTTP');
      }

      if (method == 'get') {
        url += '?' + data + new Date().getTime();
        xhr.open('get', url, flag);
      } else {
        xhr.open('post', url, flag);
      }


      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4 && xhr.status === 200) {
          // 数据已经可用了
          callBack(xhr.responseText);
        }
      }


      if (method == 'get') {
        xhr.send();
      } else {
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urle');
        xhr.send(data);
      }
    }

    // 深度clone
    function deepCopy(ori, tar) {
      var tar = tar || {};
      for (var prop in ori) {
        if (typeof (ori[prop]) == 'object') {
          tat[prop] = (ori[prop].constructor === Array) ? [] : {};
          deepCopy(ori[prop], tar[prop]);
        } else {
          tar[prop] = src[prop];
        }
      }
      return tar;
    }

    //圣杯模式
    var inherit = (function () {
        var F = function () {}
        return function (C, P) {
          F.prototype = P.prototype;
          C.prototype = new F();
          C.prototype.constructor = C;
          C.prototype.uber = P.prototype; //最后再补充一下 构造完这些 我是由谁来的 就是P.prototype
        }
      }());

      shift()
    //   删除数组的第一个元素, 返回删除的值。 这里是0
    unshift(3, 4)
    //   把参数加载数组的前面， 返回数组的长度。 现在list中是3, 4, 0, 1, 2， 返回值为5
    pop()
    //   删除数组的最后一个元素， 返回删除的值。 这里是2
    push(3)
    //   将参数加载到数组的最后， 返回数组的长度， 现在List中时： 0, 1, 2, 3， 返回值为4
    concat(3, 4)
    //   把两个数组拼接起来, 返回一个数组副本， 值为0, 1, 2, 3, 4
    splice(index, howmany, item1, ....., itemX)
    //   howmany删除项目数量， item为添加的项目
    sort():
    //   是按照字符编码的顺序进行排序, 中间加函数可实现乱序 里面传一个函数 a b a > b 看返回值 返回正值就调换顺序 返回负值不掉换
    reverse():
    //   方法用于颠倒数组中元素的顺序。
    join():
    //   方法用于把数组中的所有元素放入一个字符串。
    toString():
    //   方法可把数组转换为字符串， 并返回结果。 加radix， 也可以转化成十进制

      ===
      ===
      ===
      = 字符串常见方法 === === ==
      charCodeAt(index)
    //   方法返回一个整数， 代表指定位置字符的Unicode编码。
    fromCharCode(code1, code2...)
    //   方法从一些Unicode字符串中返回一个字符串。
    charAt(index) (填索引返回字符串)
    //   方法返回指定索引位置处的字符。 如果超出有效范围的索引值返回空字符串。
    slice(start, end) (左闭右开区间)
    //   方法返回字符串的片段。 算头不算尾。
    substring(start, end)
    //   方法用于提取字符串中介于两个指定下标之间的字符。 算头不算尾。
    substr(start, length)
    //   方法返回一个从指定位置开始的指定长度的子字符串。
    indexOf(substr, startIndex) (填字符串返回索引)
    //   方法放回String对象内第一次出现子字符串位置。 没有找到子字符串， 则返回 - 1。
    split(separator, limit)
    //   将一个字符串分割为子字符串， 然后将结果作为字符串数组返回。 limit该值用来限制返回数组中的元素个数。
    concat(string1, string2...)
    //   方法返回字符串值， 该值包含了两个或多个提供的字符串的连接。
    search() (填正则返回索引)
    //   方法返回与正则表达式查找内容匹配的第一个字符串的位置。
    toLowerCase() / toUpperCase():
    //   改变字符串中的字母大小写
    match() // 匹配正则，返回匹配上的数组
  </script>
</body>

</html>
